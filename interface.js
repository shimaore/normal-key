// Generated by CoffeeScript 1.12.7
(function() {
  var RedisInterface, debug, seem;

  seem = require('seem');

  debug = (require('tangible'))('normal-key:interface');

  RedisInterface = (function() {
    function RedisInterface(redises) {
      this.redises = redises;
    }

    RedisInterface.prototype.timeout = 24 * 3600;

    RedisInterface.prototype.all = function(cb) {
      return Promise.all(this.redises.map(cb.bind(this)));
    };

    RedisInterface.prototype.multi = function(key, cb) {
      return this.all(function(redis) {
        return cb(redis.multi()).expire(key, this.timeout).exec()["catch"](function() {
          return true;
        });
      });
    };

    RedisInterface.prototype.first = seem(function*(cb) {
      var i, len, redis, ref, v;
      cb.bind(this);
      ref = this.redises;
      for (i = 0, len = ref.length; i < len; i++) {
        redis = ref[i];
        try {
          v = (yield cb(redis));
          return v;
        } catch (error1) {}
      }
    });

    RedisInterface.prototype.set = function(key, name, value) {
      if (value != null) {
        return this.multi(function(key, redis) {
          return redis.hset(key, name, value);
        });
      } else {
        return this.all(function(redis) {
          return redis.hdel(key, name)["catch"](function() {
            return true;
          });
        });
      }
    };

    RedisInterface.prototype.get = function(key, name) {
      return this.first(function(redis) {
        return redis.hget(key, name);
      });
    };

    RedisInterface.prototype.incr = function(key, property, increment) {
      if (increment == null) {
        increment = 1;
      }
      return this.multi(function(key, redis) {
        return redis.hincrby(key, property, increment);
      });
    };

    RedisInterface.prototype.mapping = function(key) {
      return this.first(seem(function*(redis) {
        var cursor, elements, i, k, len, ref, ref1, result, v;
        result = {};
        cursor = 0;
        while (cursor !== '0') {
          ref = (yield redis.hscan(key, cursor)), cursor = ref[0], elements = ref[1];
          for (i = 0, len = elements.length; i < len; i++) {
            ref1 = elements[i], k = ref1[0], v = ref1[1];
            result[k] = v;
          }
        }
        return result;
      }));
    };

    RedisInterface.prototype.add = function(key, value) {
      if (value == null) {
        return;
      }
      return this.multi(function(key, redis) {
        return redis.sadd(key, value);
      });
    };

    RedisInterface.prototype.remove = function(key, value) {
      if (value == null) {
        return;
      }
      return this.multi(function(key, redis) {
        return redis.srem(key, value);
      });
    };

    RedisInterface.prototype.has = function(key, value) {
      if (value == null) {
        return;
      }
      return this.first(function(redis) {
        return redis.sismember(key, value);
      });
    };

    RedisInterface.prototype.count = function(key) {
      return this.first(function(redis) {
        return redis.scard(key);
      });
    };

    RedisInterface.prototype.members = function(key) {
      return this.first(function(redis) {
        return redis.smembers(key);
      });
    };

    RedisInterface.prototype.clear = seem(function(key) {
      return this.multi(function(key, redis) {
        return redis.sinterstore(key, key + "--emtpy-set--");
      });
    });

    RedisInterface.prototype.forEach = function(key, cb) {
      return this.first(seem(function*(redis) {
        var cursor, error, i, keys, len, ref, ref1;
        cursor = 0;
        while (cursor !== '0') {
          ref = (yield redis.sscan(key, cursor)), cursor = ref[0], keys = ref[1];
          for (i = 0, len = keys.length; i < len; i++) {
            key = keys[i];
            try {
              yield cb(key);
            } catch (error1) {
              error = error1;
              debug.dev("forEach cb on " + key + ": " + ((ref1 = error.stack) != null ? ref1 : error));
            }
          }
        }
      }));
    };

    RedisInterface.prototype.sorted_add = seem(function(key, value, score) {
      if (score == null) {
        score = 0;
      }
      if (value == null) {
        return;
      }
      return this.multi(function(key, redis) {
        return redis.zadd(key, score, value);
      });
    });

    RedisInterface.prototype.sorted_incr = seem(function(key, value, delta) {
      if (delta == null) {
        delta = 1;
      }
      if (value == null) {
        return;
      }
      return this.multi(function(key, redis) {
        return redis.zincrby(key, delta, value);
      });
    });

    RedisInterface.prototype.sorted_remove = seem(function(key, value) {
      if (value == null) {
        return;
      }
      return this.multi(function(key, redis) {
        return redis.zrem(key, value);
      });
    });

    RedisInterface.prototype.score = function(key, value) {
      if (value == null) {
        return;
      }
      return this.first(function(redis) {
        return redis.zscore(key, value);
      });
    };

    RedisInterface.prototype.sorted_count = function(key) {
      return this.first(function(redis) {
        return redis.zcard(key);
      });
    };

    RedisInterface.prototype.sorted_forEach = function(key, cb) {
      return this.first(seem(function*(redis) {
        var cursor, error, ref, ref1, score, values;
        cursor = 0;
        while (cursor !== '0') {
          ref = (yield redis.zscan(key, cursor)), cursor = ref[0], values = ref[1];
          while (values.length > 1) {
            key = values.shift();
            score = values.shift();
            try {
              yield cb(key, score);
            } catch (error1) {
              error = error1;
              debug.dev("sorted_forEach cb on " + key + ": " + ((ref1 = error.stack) != null ? ref1 : error));
            }
          }
        }
      }));
    };

    return RedisInterface;

  })();

  module.exports = RedisInterface;

}).call(this);
