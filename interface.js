// Generated by CoffeeScript 2.4.1
(function() {
  // RedisInterface
  // ==============
  var RedisInterface, debug, default_timeout;

  debug = (require('tangible'))('normal-key:interface');

  // Default timeout is 24h.
  default_timeout = 24 * 3600;

  RedisInterface = class RedisInterface {
    constructor(redis, __timeout = default_timeout) {
      this.redis = redis;
      this.__timeout = __timeout;
      this.redis.defineCommand('transition', {
        numberOfKeys: 1,
        lua: `local key = KEYS[1]\nlocal old_value = ARGV[1]\nlocal new_value = ARGV[2]\nlocal current_value = redis.call('get',key)\nif current_value == old_value or (current_value == false and old_value == '')\nthen\n  if new_value == '' then\n    return redis.call('del',key)\n  else\n    return redis.call('setex',key,${this.__timeout},new_value)\n  end\nelse\n  return redis.error_reply('Current value \`'..current_value..'\` does not match \`'..old_value..'\`.')\nend`
      });
    }

    timeout(timeout) {
      var self;
      return self = new RedisInterface(this.redis, timeout);
    }

    async multi(op, key, ...args) {
      var result;
      result = (await this.redis.multi([[op, key, ...args], ['expire', key, this.__timeout]]).exec().catch(function(err) {
        if (err.previousErrors != null) {
          return Promise.reject(new Error(err.previousErrors[0].message));
        }
      }));
      return result[0][1];
    }

    // Properties
    // ----------
    set(key, name, value) {
      if (value != null) {
        return this.multi('hset', key, name, value);
      } else {
        return this.redis.hdel(key, name);
      }
    }

    get(key, name) {
      return this.redis.hget(key, name);
    }

    incr(key, name, increment = 1) {
      return this.multi('hincrby', key, name, increment);
    }

    transition(key, old_value, new_value) {
      return this.redis.transition(key, old_value, new_value);
    }

    async mapping(key) {
      var cursor, elements, i, k, len, result, v;
      result = {};
      cursor = 0;
      while (cursor !== '0') {
        [cursor, elements] = (await this.redis.hscan(key, cursor));
        for (i = 0, len = elements.length; i < len; i++) {
          [k, v] = elements[i];
          result[k] = v;
        }
      }
      return result;
    }

    // Sets
    // ----
    add(key, value) {
      if (value == null) {
        return;
      }
      return this.multi('sadd', key, value);
    }

    remove(key, value) {
      if (value == null) {
        return;
      }
      return this.multi('srem', key, value);
    }

    async has(key, value) {
      var it;
      if (value == null) {
        return;
      }
      it = (await this.redis.sismember(key, value));
      if (it === 1) {
        return true;
      } else {
        return false;
      }
    }

    count(key) {
      return this.redis.scard(key);
    }

    members(key) {
      return this.redis.smembers(key);
    }

    clear(key) {
      return this.redis.sinterstore(key, `${key}--emtpy-set--`);
    }

    async forEach(key, cb) {
      var cursor, error, foo, i, len, ref, value, values;
      cursor = 0;
      while (cursor !== '0') {
        [cursor, values] = foo = (await this.redis.sscan(key, cursor));
        for (i = 0, len = values.length; i < len; i++) {
          value = values[i];
          try {
            await cb(value);
          } catch (error1) {
            error = error1;
            debug.dev(`forEach cb on ${value}: ${(ref = error.stack) != null ? ref : error}`);
          }
        }
      }
    }

    // Sorted Sets
    // -----------
    sorted_add(key, value, score = 0) {
      if (value == null) {
        return;
      }
      return this.multi('zadd', key, score, value);
    }

    sorted_incr(key, value, delta = 1) {
      if (value == null) {
        return;
      }
      return this.multi('zincrby', key, delta, value);
    }

    sorted_remove(key, value) {
      if (value == null) {
        return;
      }
      return this.multi('zrem', key, value);
    }

    async score(key, value) {
      if (value == null) {
        return;
      }
      return parseFloat((await this.redis.zscore(key, value)));
    }

    sorted_count(key) {
      return this.redis.zcard(key);
    }

    async sorted_forEach(key, cb) {
      var cursor, error, ref, score, value, values;
      cursor = 0;
      while (cursor !== '0') {
        [cursor, values] = (await this.redis.zscan(key, cursor));
        while (values.length > 1) {
          value = values.shift();
          score = values.shift();
          try {
            await cb(value, score);
          } catch (error1) {
            error = error1;
            debug.dev(`sorted_forEach cb on ${value}: ${(ref = error.stack) != null ? ref : error}`);
          }
        }
      }
    }

  };

  module.exports = RedisInterface;

}).call(this);
